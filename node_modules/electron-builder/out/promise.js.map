{"version":3,"file":"promise.js","sourceRoot":"","sources":["../src/promise.ts"],"names":[],"mappings":";;AAAA,2BAA2C,AAAU,AACrD,AAAC;AAAD,0BAA0B,AAAW,AAErC,AAAC;AAAD,MAAM,AAAS,YAAG,UAAS;AAC3B,AAAK,MAAC,AAAO,QAAC,AAAS,AAAC;AAExB,2BAAkC,AAAY;AAC5C,AAAO,YAAC,AAAK,MAAC,AAAK,MAAC,AAAK,SAAI,AAAK,MAAC,AAAO,WAAI,AAAK,AAAC;AACpD,AAAO,YAAC,AAAI,KAAC,CAAC,AAAC,AAAC,AAClB,AAAC;;AAHe,QAAiB,oBAGhC;AAGD,wBAAqC,AAAqB,SAAE,AAAqC;;AAC/F,YAAI,AAAM,SAAQ,AAAI;AACtB,YAAI,AAAC;AACH,AAAM,qBAAG,MAAM,AAAO,AACxB,AACA;iBAAO,AAAa,AAAC,eAAC,AAAC;AACrB,gBAAI,AAAC;AACH,sBAAM,AAAI,KAAC,AAAa,AAAC,AAC3B,AACA;qBAAO,AAAS,AAAC,WAAC,AAAC;AACjB,sBAAM,IAAI,AAAW,YAAC,CAAC,AAAa,eAAE,AAAS,AAAC,AAAC,AACnD,AAAC;aAFD,AAAK,AAAC;AAIN,kBAAM,AAAa,AACrB,AAAC;SATD,AAAK,AAAC;AAWN,YAAI,AAAC;AACH,kBAAM,AAAI,KAAC,AAAI,AAAC,AAClB,AACA;iBAAO,AAAS,AAAC,WAAC,AAAC;AACjB,kBAAM,AAAS,AACjB,AAAC;SAFD,AAAK,AAAC;AAGN,AAAM,eAAC,AAAM,AACf,AAAC;;;AAvBqB,QAAc,iBAuBnC;AAED,0BAAiC,AAAK;AACpC,gBAAY,AAAoB;YAAE,AAAO,gEAAW,AAAkB;;AACpE,YAAI,AAAC,IAAG,AAAO;AACf,YAAI,AAAC,IAAG,AAAC;AACT,AAAG,AAAC,aAAC,IAAI,AAAK,SAAI,AAAM,AAAC,QAAC,AAAC;AACzB,kBAAM,AAAM,SAAG,AAAS,YAAG,AAAC,AAAE,MAAG,AAAG;AACpC,AAAC,iBAAI,AAAM,SAAG,AAAM,SAAG,AAAG,IAAC,AAAM,OAAC,AAAE,AAAC,MAAG,AAAI,OAAG,AAAK,MAAC,AAAK,AAC5D,AAAC;;AACD,cAAM,AAAC,AAAC,AACV,AAAC,AACH,AAAC;;;AAVY,QAAW,cAUvB;AAED,aAAoB,AAA6B;AAC/C,UAAM,AAAM,SAAiB,AAAE;AAC/B,AAAM,WAAC,WAAe,QAAC,AAAG,IAAC,AAAQ,SAAC,AAAG,IAAC,AAAE,MAAI,AAAE,GAAC,AAAK,MAAC,AAAE,MAAI,AAAM,OAAC,AAAI,KAAC,AAAE,AAAC,AAAC,AAAC,AAAC,OAC5E,AAAI;AACH,AAAE,AAAC,YAAC,AAAM,OAAC,AAAM,WAAK,AAAC,AAAC;AACtB,kBAAM,AAAM,OAAC,AAAC,AAAC,AACjB,AAAC,AACD,AAAI,GAHqB,AAAC;mBAGjB,AAAM,OAAC,AAAM,SAAG,AAAC,AAAC,GAAC,AAAC;AAC3B,kBAAM,IAAI,AAAW,YAAC,AAAM,QAAE,AAAkB,AAAC,AACnD,AAAC,AACH,AAAC,AAAC,AACN,AAAC;SAJU,AAAE,AAAC;KAJJ;;AAHM,QAAG,MAWlB","sourcesContent":["import { Promise as BluebirdPromise } from \"bluebird\"\nimport { tsAwaiter } from \"./awaiter\"\n\nconst __awaiter = tsAwaiter\nArray.isArray(__awaiter)\n\nexport function printErrorAndExit(error: Error) {\n  console.error(error.stack || error.message || error)\n  process.exit(-1)\n}\n\n// you don't need to handle error in your task - it is passed only indicate status of promise\nexport async function executeFinally(promise: Promise<any>, task: (error?: Error) => Promise<any>): Promise<any> {\n  let result: any = null\n  try {\n    result = await promise\n  }\n  catch (originalError) {\n    try {\n      await task(originalError)\n    }\n    catch (taskError) {\n      throw new NestedError([originalError, taskError])\n    }\n\n    throw originalError\n  }\n\n  try {\n    await task(null)\n  }\n  catch (taskError) {\n    throw taskError\n  }\n  return result\n}\n\nexport class NestedError extends Error {\n  constructor(errors: Array<Error>, message: string = \"Compound error: \") {\n    let m = message\n    let i = 1\n    for (let error of errors) {\n      const prefix = \"Error #\" + i++ + \" \"\n      m += \"\\n\\n\" + prefix + \"-\".repeat(80) + \"\\n\" + error.stack\n    }\n    super(m)\n  }\n}\n\nexport function all(promises: Array<Promise<any>>): BluebirdPromise<any> {\n  const errors: Array<Error> = []\n  return BluebirdPromise.all(promises.map(it => it.catch(it => errors.push(it))))\n    .then(() => {\n      if (errors.length === 1) {\n        throw errors[0]\n      }\n      else if (errors.length > 1) {\n        throw new NestedError(errors, \"Cannot cleanup: \")\n      }\n    })\n}"]}